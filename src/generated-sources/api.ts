/* tslint:disable */
/* eslint-disable */
/**
 * MarzbanAPI
 * Unified GUI Censorship Resistant Solution Powered by Xray
 *
 * The version of the OpenAPI document: 0.8.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Admin
 */
export interface Admin {
    /**
     * 
     * @type {string}
     * @memberof Admin
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof Admin
     */
    'is_sudo': boolean;
    /**
     * 
     * @type {number}
     * @memberof Admin
     */
    'telegram_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Admin
     */
    'discord_webhook'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Admin
     */
    'users_usage'?: number | null;
}
/**
 * 
 * @export
 * @interface AdminCreate
 */
export interface AdminCreate {
    /**
     * 
     * @type {string}
     * @memberof AdminCreate
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof AdminCreate
     */
    'is_sudo': boolean;
    /**
     * 
     * @type {number}
     * @memberof AdminCreate
     */
    'telegram_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AdminCreate
     */
    'discord_webhook'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AdminCreate
     */
    'users_usage'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AdminCreate
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AdminModify
 */
export interface AdminModify {
    /**
     * 
     * @type {string}
     * @memberof AdminModify
     */
    'password'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof AdminModify
     */
    'is_sudo': boolean;
    /**
     * 
     * @type {number}
     * @memberof AdminModify
     */
    'telegram_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof AdminModify
     */
    'discord_webhook'?: string | null;
}
/**
 * 
 * @export
 * @interface Conflict
 */
export interface Conflict {
    /**
     * 
     * @type {string}
     * @memberof Conflict
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface CoreStats
 */
export interface CoreStats {
    /**
     * 
     * @type {string}
     * @memberof CoreStats
     */
    'version': string;
    /**
     * 
     * @type {boolean}
     * @memberof CoreStats
     */
    'started': boolean;
    /**
     * 
     * @type {string}
     * @memberof CoreStats
     */
    'logs_websocket': string;
}
/**
 * 
 * @export
 * @interface Forbidden
 */
export interface Forbidden {
    /**
     * 
     * @type {string}
     * @memberof Forbidden
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface HTTPException
 */
export interface HTTPException {
    /**
     * 
     * @type {string}
     * @memberof HTTPException
     */
    'detail': string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface NextPlanModel
 */
export interface NextPlanModel {
    /**
     * 
     * @type {number}
     * @memberof NextPlanModel
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NextPlanModel
     */
    'expire'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof NextPlanModel
     */
    'add_remaining_traffic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NextPlanModel
     */
    'fire_on_either'?: boolean;
}
/**
 * 
 * @export
 * @interface NodeCreate
 */
export interface NodeCreate {
    /**
     * 
     * @type {string}
     * @memberof NodeCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeCreate
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof NodeCreate
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeCreate
     */
    'api_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeCreate
     */
    'usage_coefficient'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NodeCreate
     */
    'add_as_new_host'?: boolean;
}
/**
 * 
 * @export
 * @interface NodeModify
 */
export interface NodeModify {
    /**
     * 
     * @type {string}
     * @memberof NodeModify
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NodeModify
     */
    'address'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NodeModify
     */
    'port'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodeModify
     */
    'api_port'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NodeModify
     */
    'usage_coefficient'?: number | null;
    /**
     * 
     * @type {NodeStatus}
     * @memberof NodeModify
     */
    'status'?: NodeStatus | null;
}


/**
 * 
 * @export
 * @interface NodeResponse
 */
export interface NodeResponse {
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof NodeResponse
     */
    'port'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeResponse
     */
    'api_port'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeResponse
     */
    'usage_coefficient'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeResponse
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'xray_version'?: string | null;
    /**
     * 
     * @type {NodeStatus}
     * @memberof NodeResponse
     */
    'status': NodeStatus;
    /**
     * 
     * @type {string}
     * @memberof NodeResponse
     */
    'message'?: string | null;
}


/**
 * 
 * @export
 * @interface NodeSettings
 */
export interface NodeSettings {
    /**
     * 
     * @type {string}
     * @memberof NodeSettings
     */
    'min_node_version'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeSettings
     */
    'certificate': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NodeStatus = {
    Connected: 'connected',
    Connecting: 'connecting',
    Error: 'error',
    Disabled: 'disabled'
} as const;

export type NodeStatus = typeof NodeStatus[keyof typeof NodeStatus];


/**
 * 
 * @export
 * @interface NodeUsageResponse
 */
export interface NodeUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof NodeUsageResponse
     */
    'node_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof NodeUsageResponse
     */
    'node_name': string;
    /**
     * 
     * @type {number}
     * @memberof NodeUsageResponse
     */
    'uplink': number;
    /**
     * 
     * @type {number}
     * @memberof NodeUsageResponse
     */
    'downlink': number;
}
/**
 * 
 * @export
 * @interface NodesUsageResponse
 */
export interface NodesUsageResponse {
    /**
     * 
     * @type {Array<NodeUsageResponse>}
     * @memberof NodesUsageResponse
     */
    'usages': Array<NodeUsageResponse>;
}
/**
 * 
 * @export
 * @interface NotFound
 */
export interface NotFound {
    /**
     * 
     * @type {string}
     * @memberof NotFound
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface Port
 */
export interface Port {
}
/**
 * 
 * @export
 * @interface ProxyHost
 */
export interface ProxyHost {
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'remark': string;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'address': string;
    /**
     * 
     * @type {number}
     * @memberof ProxyHost
     */
    'port'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'sni'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'host'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'path'?: string | null;
    /**
     * 
     * @type {ProxyHostSecurity}
     * @memberof ProxyHost
     */
    'security'?: ProxyHostSecurity;
    /**
     * 
     * @type {ProxyHostALPN}
     * @memberof ProxyHost
     */
    'alpn'?: ProxyHostALPN;
    /**
     * 
     * @type {ProxyHostFingerprint}
     * @memberof ProxyHost
     */
    'fingerprint'?: ProxyHostFingerprint;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyHost
     */
    'allowinsecure'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyHost
     */
    'is_disabled'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyHost
     */
    'mux_enable'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'fragment_setting'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProxyHost
     */
    'noise_setting'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyHost
     */
    'random_user_agent'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProxyHost
     */
    'use_sni_as_host'?: boolean | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProxyHostALPN = {
    Empty: '',
    H3: 'h3',
    H2: 'h2',
    Http11: 'http/1.1',
    H3h2http11: 'h3,h2,http/1.1',
    H3h2: 'h3,h2',
    H2http11: 'h2,http/1.1'
} as const;

export type ProxyHostALPN = typeof ProxyHostALPN[keyof typeof ProxyHostALPN];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProxyHostFingerprint = {
    Empty: '',
    Chrome: 'chrome',
    Firefox: 'firefox',
    Safari: 'safari',
    Ios: 'ios',
    Android: 'android',
    Edge: 'edge',
    _360: '360',
    Qq: 'qq',
    Random: 'random',
    Randomized: 'randomized'
} as const;

export type ProxyHostFingerprint = typeof ProxyHostFingerprint[keyof typeof ProxyHostFingerprint];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProxyHostSecurity = {
    InboundDefault: 'inbound_default',
    None: 'none',
    Tls: 'tls'
} as const;

export type ProxyHostSecurity = typeof ProxyHostSecurity[keyof typeof ProxyHostSecurity];


/**
 * 
 * @export
 * @interface ProxyInbound
 */
export interface ProxyInbound {
    /**
     * 
     * @type {string}
     * @memberof ProxyInbound
     */
    'tag': string;
    /**
     * 
     * @type {ProxyTypes}
     * @memberof ProxyInbound
     */
    'protocol': ProxyTypes;
    /**
     * 
     * @type {string}
     * @memberof ProxyInbound
     */
    'network': string;
    /**
     * 
     * @type {string}
     * @memberof ProxyInbound
     */
    'tls': string;
    /**
     * 
     * @type {Port}
     * @memberof ProxyInbound
     */
    'port': Port;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProxyTypes = {
    Vmess: 'vmess',
    Vless: 'vless',
    Trojan: 'trojan',
    Shadowsocks: 'shadowsocks'
} as const;

export type ProxyTypes = typeof ProxyTypes[keyof typeof ProxyTypes];


/**
 * 
 * @export
 * @interface SubscriptionUserResponse
 */
export interface SubscriptionUserResponse {
    /**
     * 
     * @type {object}
     * @memberof SubscriptionUserResponse
     */
    'proxies': object;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUserResponse
     */
    'expire'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUserResponse
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {UserDataLimitResetStrategy}
     * @memberof SubscriptionUserResponse
     */
    'data_limit_reset_strategy'?: UserDataLimitResetStrategy;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'sub_updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'sub_last_user_agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'online_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUserResponse
     */
    'on_hold_expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'on_hold_timeout'?: string | null;
    /**
     * 
     * @type {NextPlanModel}
     * @memberof SubscriptionUserResponse
     */
    'next_plan'?: NextPlanModel | null;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'username': string;
    /**
     * 
     * @type {UserStatus}
     * @memberof SubscriptionUserResponse
     */
    'status': UserStatus;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUserResponse
     */
    'used_traffic': number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionUserResponse
     */
    'lifetime_used_traffic'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriptionUserResponse
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionUserResponse
     */
    'subscription_url'?: string;
}


/**
 * 
 * @export
 * @interface SystemStats
 */
export interface SystemStats {
    /**
     * 
     * @type {string}
     * @memberof SystemStats
     */
    'version': string;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'mem_total': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'mem_used': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'cpu_cores': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'cpu_usage': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'total_user': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'online_users': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'users_active': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'users_on_hold': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'users_disabled': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'users_expired': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'users_limited': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'incoming_bandwidth': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'outgoing_bandwidth': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'incoming_bandwidth_speed': number;
    /**
     * 
     * @type {number}
     * @memberof SystemStats
     */
    'outgoing_bandwidth_speed': number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_type'?: string;
}
/**
 * 
 * @export
 * @interface Unauthorized
 */
export interface Unauthorized {
    /**
     * 
     * @type {string}
     * @memberof Unauthorized
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UserCreate
     */
    'proxies'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'expire'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {UserDataLimitResetStrategy}
     * @memberof UserCreate
     */
    'data_limit_reset_strategy'?: UserDataLimitResetStrategy;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserCreate
     */
    'inbounds'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'sub_updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'sub_last_user_agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'online_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'on_hold_expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'on_hold_timeout'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserCreate
     */
    'auto_delete_in_days'?: number | null;
    /**
     * 
     * @type {NextPlanModel}
     * @memberof UserCreate
     */
    'next_plan'?: NextPlanModel | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'username': string;
    /**
     * 
     * @type {UserStatusCreate}
     * @memberof UserCreate
     */
    'status'?: UserStatusCreate;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserDataLimitResetStrategy = {
    NoReset: 'no_reset',
    Day: 'day',
    Week: 'week',
    Month: 'month',
    Year: 'year'
} as const;

export type UserDataLimitResetStrategy = typeof UserDataLimitResetStrategy[keyof typeof UserDataLimitResetStrategy];


/**
 * 
 * @export
 * @interface UserModify
 */
export interface UserModify {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UserModify
     */
    'proxies'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof UserModify
     */
    'expire'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserModify
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {UserDataLimitResetStrategy}
     * @memberof UserModify
     */
    'data_limit_reset_strategy'?: UserDataLimitResetStrategy;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserModify
     */
    'inbounds'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof UserModify
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModify
     */
    'sub_updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModify
     */
    'sub_last_user_agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserModify
     */
    'online_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserModify
     */
    'on_hold_expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserModify
     */
    'on_hold_timeout'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserModify
     */
    'auto_delete_in_days'?: number | null;
    /**
     * 
     * @type {NextPlanModel}
     * @memberof UserModify
     */
    'next_plan'?: NextPlanModel | null;
    /**
     * 
     * @type {UserStatusModify}
     * @memberof UserModify
     */
    'status'?: UserStatusModify;
}


/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {object}
     * @memberof UserResponse
     */
    'proxies': object;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'expire'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {UserDataLimitResetStrategy}
     * @memberof UserResponse
     */
    'data_limit_reset_strategy'?: UserDataLimitResetStrategy;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserResponse
     */
    'inbounds'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'note'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'sub_updated_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'sub_last_user_agent'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'online_at'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'on_hold_expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'on_hold_timeout'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'auto_delete_in_days'?: number | null;
    /**
     * 
     * @type {NextPlanModel}
     * @memberof UserResponse
     */
    'next_plan'?: NextPlanModel | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {UserStatus}
     * @memberof UserResponse
     */
    'status': UserStatus;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'used_traffic': number;
    /**
     * 
     * @type {number}
     * @memberof UserResponse
     */
    'lifetime_used_traffic'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'created_at': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserResponse
     */
    'links'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'subscription_url'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserResponse
     */
    'excluded_inbounds'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {Admin}
     * @memberof UserResponse
     */
    'admin'?: Admin | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatus = {
    Active: 'active',
    Disabled: 'disabled',
    Limited: 'limited',
    Expired: 'expired',
    OnHold: 'on_hold'
} as const;

export type UserStatus = typeof UserStatus[keyof typeof UserStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatusCreate = {
    Active: 'active',
    OnHold: 'on_hold'
} as const;

export type UserStatusCreate = typeof UserStatusCreate[keyof typeof UserStatusCreate];


/**
 * 
 * @export
 * @enum {string}
 */

export const UserStatusModify = {
    Active: 'active',
    Disabled: 'disabled',
    OnHold: 'on_hold'
} as const;

export type UserStatusModify = typeof UserStatusModify[keyof typeof UserStatusModify];


/**
 * 
 * @export
 * @interface UserTemplateCreate
 */
export interface UserTemplateCreate {
    /**
     * 
     * @type {string}
     * @memberof UserTemplateCreate
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateCreate
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateCreate
     */
    'expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateCreate
     */
    'username_prefix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateCreate
     */
    'username_suffix'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserTemplateCreate
     */
    'inbounds'?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface UserTemplateModify
 */
export interface UserTemplateModify {
    /**
     * 
     * @type {string}
     * @memberof UserTemplateModify
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateModify
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateModify
     */
    'expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateModify
     */
    'username_prefix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateModify
     */
    'username_suffix'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserTemplateModify
     */
    'inbounds'?: { [key: string]: Array<string>; };
}
/**
 * 
 * @export
 * @interface UserTemplateResponse
 */
export interface UserTemplateResponse {
    /**
     * 
     * @type {string}
     * @memberof UserTemplateResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateResponse
     */
    'data_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof UserTemplateResponse
     */
    'expire_duration'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateResponse
     */
    'username_prefix'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserTemplateResponse
     */
    'username_suffix'?: string | null;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof UserTemplateResponse
     */
    'inbounds'?: { [key: string]: Array<string>; };
    /**
     * 
     * @type {number}
     * @memberof UserTemplateResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface UserUsageResponse
 */
export interface UserUsageResponse {
    /**
     * 
     * @type {number}
     * @memberof UserUsageResponse
     */
    'node_id'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserUsageResponse
     */
    'node_name': string;
    /**
     * 
     * @type {number}
     * @memberof UserUsageResponse
     */
    'used_traffic': number;
}
/**
 * 
 * @export
 * @interface UserUsagesResponse
 */
export interface UserUsagesResponse {
    /**
     * 
     * @type {string}
     * @memberof UserUsagesResponse
     */
    'username': string;
    /**
     * 
     * @type {Array<UserUsageResponse>}
     * @memberof UserUsagesResponse
     */
    'usages': Array<UserUsageResponse>;
}
/**
 * 
 * @export
 * @interface UsersResponse
 */
export interface UsersResponse {
    /**
     * 
     * @type {Array<UserResponse>}
     * @memberof UsersResponse
     */
    'users': Array<UserResponse>;
    /**
     * 
     * @type {number}
     * @memberof UsersResponse
     */
    'total': number;
}
/**
 * 
 * @export
 * @interface UsersUsagesResponse
 */
export interface UsersUsagesResponse {
    /**
     * 
     * @type {Array<UserUsageResponse>}
     * @memberof UsersUsagesResponse
     */
    'usages': Array<UserUsageResponse>;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate all disabled users under a specific admin
         * @summary Activate All Disabled Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllDisabledUsers: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activateAllDisabledUsers', 'username', username)
            const localVarPath = `/api/admin/{username}/users/activate`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate an admin and issue a token.
         * @summary Admin Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminToken: async (username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('adminToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('adminToken', 'password', password)
            const localVarPath = `/api/admin/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new admin if the current admin has sudo privileges.
         * @summary Create Admin
         * @param {AdminCreate} adminCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdmin: async (adminCreate: AdminCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adminCreate' is not null or undefined
            assertParamExists('createAdmin', 'adminCreate', adminCreate)
            const localVarPath = `/api/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable all active users under a specific admin
         * @summary Disable All Active Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAllActiveUsers: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('disableAllActiveUsers', 'username', username)
            const localVarPath = `/api/admin/{username}/users/disable`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the usage of given admin.
         * @summary Get Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminUsage: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getAdminUsage', 'username', username)
            const localVarPath = `/api/admin/usage/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of admins with optional filters for pagination and username.
         * @summary Get Admins
         * @param {number | null} [offset] 
         * @param {number | null} [limit] 
         * @param {string | null} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins: async (offset?: number | null, limit?: number | null, username?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current authenticated admin.
         * @summary Get Current Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAdmin: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing admin\'s details.
         * @summary Modify Admin
         * @param {string} username 
         * @param {AdminModify} adminModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAdmin: async (username: string, adminModify: AdminModify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('modifyAdmin', 'username', username)
            // verify required parameter 'adminModify' is not null or undefined
            assertParamExists('modifyAdmin', 'adminModify', adminModify)
            const localVarPath = `/api/admin/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adminModify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an admin from the database.
         * @summary Remove Admin
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAdmin: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeAdmin', 'username', username)
            const localVarPath = `/api/admin/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets usage of admin.
         * @summary Reset Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAdminUsage: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('resetAdminUsage', 'username', username)
            const localVarPath = `/api/admin/usage/reset/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate all disabled users under a specific admin
         * @summary Activate All Disabled Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateAllDisabledUsers(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateAllDisabledUsers(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.activateAllDisabledUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate an admin and issue a token.
         * @summary Admin Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Token>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminToken(username, password, grantType, scope, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.adminToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new admin if the current admin has sudo privileges.
         * @summary Create Admin
         * @param {AdminCreate} adminCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAdmin(adminCreate: AdminCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAdmin(adminCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable all active users under a specific admin
         * @summary Disable All Active Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableAllActiveUsers(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableAllActiveUsers(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.disableAllActiveUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage of given admin.
         * @summary Get Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdminUsage(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdminUsage(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getAdminUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of admins with optional filters for pagination and username.
         * @summary Get Admins
         * @param {number | null} [offset] 
         * @param {number | null} [limit] 
         * @param {string | null} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdmins(offset?: number | null, limit?: number | null, username?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Admin>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdmins(offset, limit, username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getAdmins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current authenticated admin.
         * @summary Get Current Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentAdmin(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentAdmin(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getCurrentAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify an existing admin\'s details.
         * @summary Modify Admin
         * @param {string} username 
         * @param {AdminModify} adminModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyAdmin(username: string, adminModify: AdminModify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyAdmin(username, adminModify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.modifyAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove an admin from the database.
         * @summary Remove Admin
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeAdmin(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeAdmin(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.removeAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets usage of admin.
         * @summary Reset Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetAdminUsage(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Admin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetAdminUsage(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.resetAdminUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Activate all disabled users under a specific admin
         * @summary Activate All Disabled Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateAllDisabledUsers(username: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.activateAllDisabledUsers(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate an admin and issue a token.
         * @summary Admin Token
         * @param {string} username 
         * @param {string} password 
         * @param {string | null} [grantType] 
         * @param {string} [scope] 
         * @param {string | null} [clientId] 
         * @param {string | null} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Token> {
            return localVarFp.adminToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new admin if the current admin has sudo privileges.
         * @summary Create Admin
         * @param {AdminCreate} adminCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAdmin(adminCreate: AdminCreate, options?: RawAxiosRequestConfig): AxiosPromise<Admin> {
            return localVarFp.createAdmin(adminCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable all active users under a specific admin
         * @summary Disable All Active Users
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableAllActiveUsers(username: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.disableAllActiveUsers(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage of given admin.
         * @summary Get Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdminUsage(username: string, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getAdminUsage(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of admins with optional filters for pagination and username.
         * @summary Get Admins
         * @param {number | null} [offset] 
         * @param {number | null} [limit] 
         * @param {string | null} [username] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins(offset?: number | null, limit?: number | null, username?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<Admin>> {
            return localVarFp.getAdmins(offset, limit, username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current authenticated admin.
         * @summary Get Current Admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAdmin(options?: RawAxiosRequestConfig): AxiosPromise<Admin> {
            return localVarFp.getCurrentAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing admin\'s details.
         * @summary Modify Admin
         * @param {string} username 
         * @param {AdminModify} adminModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAdmin(username: string, adminModify: AdminModify, options?: RawAxiosRequestConfig): AxiosPromise<Admin> {
            return localVarFp.modifyAdmin(username, adminModify, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove an admin from the database.
         * @summary Remove Admin
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAdmin(username: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeAdmin(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets usage of admin.
         * @summary Reset Admin Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetAdminUsage(username: string, options?: RawAxiosRequestConfig): AxiosPromise<Admin> {
            return localVarFp.resetAdminUsage(username, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Activate all disabled users under a specific admin
     * @summary Activate All Disabled Users
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public activateAllDisabledUsers(username: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).activateAllDisabledUsers(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Authenticate an admin and issue a token.
     * @summary Admin Token
     * @param {string} username 
     * @param {string} password 
     * @param {string | null} [grantType] 
     * @param {string} [scope] 
     * @param {string | null} [clientId] 
     * @param {string | null} [clientSecret] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminToken(username: string, password: string, grantType?: string | null, scope?: string, clientId?: string | null, clientSecret?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminToken(username, password, grantType, scope, clientId, clientSecret, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Create a new admin if the current admin has sudo privileges.
     * @summary Create Admin
     * @param {AdminCreate} adminCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createAdmin(adminCreate: AdminCreate, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createAdmin(adminCreate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Disable all active users under a specific admin
     * @summary Disable All Active Users
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public disableAllActiveUsers(username: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).disableAllActiveUsers(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve the usage of given admin.
     * @summary Get Admin Usage
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAdminUsage(username: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAdminUsage(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Fetch a list of admins with optional filters for pagination and username.
     * @summary Get Admins
     * @param {number | null} [offset] 
     * @param {number | null} [limit] 
     * @param {string | null} [username] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getAdmins(offset?: number | null, limit?: number | null, username?: string | null, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getAdmins(offset, limit, username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve the current authenticated admin.
     * @summary Get Current Admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getCurrentAdmin(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getCurrentAdmin(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify an existing admin\'s details.
     * @summary Modify Admin
     * @param {string} username 
     * @param {AdminModify} adminModify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public modifyAdmin(username: string, adminModify: AdminModify, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).modifyAdmin(username, adminModify, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Remove an admin from the database.
     * @summary Remove Admin
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public removeAdmin(username: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).removeAdmin(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Resets usage of admin.
     * @summary Reset Admin Usage
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public resetAdminUsage(username: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).resetAdminUsage(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * CoreApi - axios parameter creator
 * @export
 */
export const CoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current core configuration.
         * @summary Get Core Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve core statistics such as version and uptime.
         * @summary Get Core Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify the core configuration and restart the core.
         * @summary Modify Core Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCoreConfig: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('modifyCoreConfig', 'body', body)
            const localVarPath = `/api/core/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restart the core and all connected nodes.
         * @summary Restart Core
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartCore: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/core/restart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CoreApi - functional programming interface
 * @export
 */
export const CoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CoreApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current core configuration.
         * @summary Get Core Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoreConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoreConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getCoreConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve core statistics such as version and uptime.
         * @summary Get Core Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoreStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CoreStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoreStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.getCoreStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify the core configuration and restart the core.
         * @summary Modify Core Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyCoreConfig(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyCoreConfig(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.modifyCoreConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restart the core and all connected nodes.
         * @summary Restart Core
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartCore(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartCore(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CoreApi.restartCore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CoreApi - factory interface
 * @export
 */
export const CoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CoreApiFp(configuration)
    return {
        /**
         * Get the current core configuration.
         * @summary Get Core Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreConfig(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getCoreConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve core statistics such as version and uptime.
         * @summary Get Core Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoreStats(options?: RawAxiosRequestConfig): AxiosPromise<CoreStats> {
            return localVarFp.getCoreStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Modify the core configuration and restart the core.
         * @summary Modify Core Config
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCoreConfig(body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.modifyCoreConfig(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Restart the core and all connected nodes.
         * @summary Restart Core
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartCore(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.restartCore(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CoreApi - object-oriented interface
 * @export
 * @class CoreApi
 * @extends {BaseAPI}
 */
export class CoreApi extends BaseAPI {
    /**
     * Get the current core configuration.
     * @summary Get Core Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getCoreConfig(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getCoreConfig(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve core statistics such as version and uptime.
     * @summary Get Core Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public getCoreStats(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).getCoreStats(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify the core configuration and restart the core.
     * @summary Modify Core Config
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public modifyCoreConfig(body: object, options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).modifyCoreConfig(body, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Restart the core and all connected nodes.
     * @summary Restart Core
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoreApi
     */
    public restartCore(options?: RawAxiosRequestConfig) {
        return CoreApiFp(this.configuration).restartCore(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        base: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async base(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.base(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.base']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Base
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        base(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.base(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Base
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public base(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).base(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * NodeApi - axios parameter creator
 * @export
 */
export const NodeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new node to the database and optionally add it as a host.
         * @summary Add Node
         * @param {NodeCreate} nodeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNode: async (nodeCreate: NodeCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeCreate' is not null or undefined
            assertParamExists('addNode', 'nodeCreate', nodeCreate)
            const localVarPath = `/api/node`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of a specific node by its ID.
         * @summary Get Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode: async (nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('getNode', 'nodeId', nodeId)
            const localVarPath = `/api/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the current node settings, including TLS certificate.
         * @summary Get Node Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/node/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all nodes. Accessible only to sudo admins.
         * @summary Get Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve usage statistics for nodes within a specified date range.
         * @summary Get Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: async (start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/nodes/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a node\'s details. Only accessible to sudo admins.
         * @summary Modify Node
         * @param {number} nodeId 
         * @param {NodeModify} nodeModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyNode: async (nodeId: number, nodeModify: NodeModify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('modifyNode', 'nodeId', nodeId)
            // verify required parameter 'nodeModify' is not null or undefined
            assertParamExists('modifyNode', 'nodeModify', nodeModify)
            const localVarPath = `/api/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeModify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a reconnection for the specified node. Only accessible to sudo admins.
         * @summary Reconnect Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reconnectNode: async (nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('reconnectNode', 'nodeId', nodeId)
            const localVarPath = `/api/node/{node_id}/reconnect`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a node and remove it from xray in the background.
         * @summary Remove Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNode: async (nodeId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeId' is not null or undefined
            assertParamExists('removeNode', 'nodeId', nodeId)
            const localVarPath = `/api/node/{node_id}`
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeApi - functional programming interface
 * @export
 */
export const NodeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodeApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new node to the database and optionally add it as a host.
         * @summary Add Node
         * @param {NodeCreate} nodeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addNode(nodeCreate: NodeCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addNode(nodeCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.addNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of a specific node by its ID.
         * @summary Get Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNode(nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNode(nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.getNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the current node settings, including TLS certificate.
         * @summary Get Node Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeSettings(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeSettings>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeSettings(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.getNodeSettings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all nodes. Accessible only to sudo admins.
         * @summary Get Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.getNodes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve usage statistics for nodes within a specified date range.
         * @summary Get Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsage(start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodesUsageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsage(start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.getUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a node\'s details. Only accessible to sudo admins.
         * @summary Modify Node
         * @param {number} nodeId 
         * @param {NodeModify} nodeModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyNode(nodeId: number, nodeModify: NodeModify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyNode(nodeId, nodeModify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.modifyNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a reconnection for the specified node. Only accessible to sudo admins.
         * @summary Reconnect Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reconnectNode(nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reconnectNode(nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.reconnectNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a node and remove it from xray in the background.
         * @summary Remove Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeNode(nodeId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeNode(nodeId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NodeApi.removeNode']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NodeApi - factory interface
 * @export
 */
export const NodeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodeApiFp(configuration)
    return {
        /**
         * Add a new node to the database and optionally add it as a host.
         * @summary Add Node
         * @param {NodeCreate} nodeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addNode(nodeCreate: NodeCreate, options?: RawAxiosRequestConfig): AxiosPromise<NodeResponse> {
            return localVarFp.addNode(nodeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of a specific node by its ID.
         * @summary Get Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<NodeResponse> {
            return localVarFp.getNode(nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the current node settings, including TLS certificate.
         * @summary Get Node Settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeSettings(options?: RawAxiosRequestConfig): AxiosPromise<NodeSettings> {
            return localVarFp.getNodeSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all nodes. Accessible only to sudo admins.
         * @summary Get Nodes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodes(options?: RawAxiosRequestConfig): AxiosPromise<Array<NodeResponse>> {
            return localVarFp.getNodes(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve usage statistics for nodes within a specified date range.
         * @summary Get Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<NodesUsageResponse> {
            return localVarFp.getUsage(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a node\'s details. Only accessible to sudo admins.
         * @summary Modify Node
         * @param {number} nodeId 
         * @param {NodeModify} nodeModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyNode(nodeId: number, nodeModify: NodeModify, options?: RawAxiosRequestConfig): AxiosPromise<NodeResponse> {
            return localVarFp.modifyNode(nodeId, nodeModify, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a reconnection for the specified node. Only accessible to sudo admins.
         * @summary Reconnect Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reconnectNode(nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.reconnectNode(nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a node and remove it from xray in the background.
         * @summary Remove Node
         * @param {number} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeNode(nodeId: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeNode(nodeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NodeApi - object-oriented interface
 * @export
 * @class NodeApi
 * @extends {BaseAPI}
 */
export class NodeApi extends BaseAPI {
    /**
     * Add a new node to the database and optionally add it as a host.
     * @summary Add Node
     * @param {NodeCreate} nodeCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public addNode(nodeCreate: NodeCreate, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).addNode(nodeCreate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve details of a specific node by its ID.
     * @summary Get Node
     * @param {number} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getNode(nodeId: number, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).getNode(nodeId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve the current node settings, including TLS certificate.
     * @summary Get Node Settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getNodeSettings(options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).getNodeSettings(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve a list of all nodes. Accessible only to sudo admins.
     * @summary Get Nodes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getNodes(options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).getNodes(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve usage statistics for nodes within a specified date range.
     * @summary Get Usage
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public getUsage(start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).getUsage(start, end, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Update a node\'s details. Only accessible to sudo admins.
     * @summary Modify Node
     * @param {number} nodeId 
     * @param {NodeModify} nodeModify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public modifyNode(nodeId: number, nodeModify: NodeModify, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).modifyNode(nodeId, nodeModify, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Trigger a reconnection for the specified node. Only accessible to sudo admins.
     * @summary Reconnect Node
     * @param {number} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public reconnectNode(nodeId: number, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).reconnectNode(nodeId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Delete a node and remove it from xray in the background.
     * @summary Remove Node
     * @param {number} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeApi
     */
    public removeNode(nodeId: number, options?: RawAxiosRequestConfig) {
        return NodeApiFp(this.configuration).removeNode(nodeId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
export const SubscriptionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the usage statistics for the user within a specified date range.
         * @summary User Get Usage
         * @param {string} token 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsage: async (token: string, start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userGetUsage', 'token', token)
            const localVarPath = `/sub/{token}/usage`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a subscription link based on the user agent (Clash, V2Ray, etc.).
         * @summary User Subscription
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscription: async (token: string, userAgent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userSubscription', 'token', token)
            const localVarPath = `/sub/{token}/`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves detailed information about the user\'s subscription.
         * @summary User Subscription Info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionInfo: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userSubscriptionInfo', 'token', token)
            const localVarPath = `/sub/{token}/info`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provides a subscription link based on the specified client type (e.g., Clash, V2Ray).
         * @summary User Subscription With Client Type
         * @param {string} clientType 
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionWithClientType: async (clientType: string, token: string, userAgent?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientType' is not null or undefined
            assertParamExists('userSubscriptionWithClientType', 'clientType', clientType)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userSubscriptionWithClientType', 'token', token)
            const localVarPath = `/sub/{token}/{client_type}`
                .replace(`{${"client_type"}}`, encodeURIComponent(String(clientType)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches the usage statistics for the user within a specified date range.
         * @summary User Get Usage
         * @param {string} token 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetUsage(token: string, start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetUsage(token, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.userGetUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provides a subscription link based on the user agent (Clash, V2Ray, etc.).
         * @summary User Subscription
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSubscription(token: string, userAgent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSubscription(token, userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.userSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves detailed information about the user\'s subscription.
         * @summary User Subscription Info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSubscriptionInfo(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSubscriptionInfo(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.userSubscriptionInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provides a subscription link based on the specified client type (e.g., Clash, V2Ray).
         * @summary User Subscription With Client Type
         * @param {string} clientType 
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSubscriptionWithClientType(clientType: string, token: string, userAgent?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSubscriptionWithClientType(clientType, token, userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionApi.userSubscriptionWithClientType']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionApiFp(configuration)
    return {
        /**
         * Fetches the usage statistics for the user within a specified date range.
         * @summary User Get Usage
         * @param {string} token 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsage(token: string, start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.userGetUsage(token, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a subscription link based on the user agent (Clash, V2Ray, etc.).
         * @summary User Subscription
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscription(token: string, userAgent?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.userSubscription(token, userAgent, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves detailed information about the user\'s subscription.
         * @summary User Subscription Info
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionInfo(token: string, options?: RawAxiosRequestConfig): AxiosPromise<SubscriptionUserResponse> {
            return localVarFp.userSubscriptionInfo(token, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides a subscription link based on the specified client type (e.g., Clash, V2Ray).
         * @summary User Subscription With Client Type
         * @param {string} clientType 
         * @param {string} token 
         * @param {string} [userAgent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSubscriptionWithClientType(clientType: string, token: string, userAgent?: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.userSubscriptionWithClientType(clientType, token, userAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI {
    /**
     * Fetches the usage statistics for the user within a specified date range.
     * @summary User Get Usage
     * @param {string} token 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public userGetUsage(token: string, start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).userGetUsage(token, start, end, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Provides a subscription link based on the user agent (Clash, V2Ray, etc.).
     * @summary User Subscription
     * @param {string} token 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public userSubscription(token: string, userAgent?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).userSubscription(token, userAgent, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieves detailed information about the user\'s subscription.
     * @summary User Subscription Info
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public userSubscriptionInfo(token: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).userSubscriptionInfo(token, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Provides a subscription link based on the specified client type (e.g., Clash, V2Ray).
     * @summary User Subscription With Client Type
     * @param {string} clientType 
     * @param {string} token 
     * @param {string} [userAgent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public userSubscriptionWithClientType(clientType: string, token: string, userAgent?: string, options?: RawAxiosRequestConfig) {
        return SubscriptionApiFp(this.configuration).userSubscriptionWithClientType(clientType, token, userAgent, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of proxy hosts grouped by inbound tag.
         * @summary Get Hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve inbound configurations grouped by protocol.
         * @summary Get Inbounds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbounds: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/inbounds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch system stats including memory, CPU, and user metrics.
         * @summary Get System Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify proxy hosts and update the configuration.
         * @summary Modify Hosts
         * @param {{ [key: string]: Array<ProxyHost>; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyHosts: async (requestBody: { [key: string]: Array<ProxyHost>; }, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('modifyHosts', 'requestBody', requestBody)
            const localVarPath = `/api/hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of proxy hosts grouped by inbound tag.
         * @summary Get Hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<ProxyHost>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve inbound configurations grouped by protocol.
         * @summary Get Inbounds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInbounds(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<ProxyInbound>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInbounds(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getInbounds']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch system stats including memory, CPU, and user metrics.
         * @summary Get System Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getSystemStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify proxy hosts and update the configuration.
         * @summary Modify Hosts
         * @param {{ [key: string]: Array<ProxyHost>; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyHosts(requestBody: { [key: string]: Array<ProxyHost>; }, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<ProxyHost>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyHosts(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.modifyHosts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * Get a list of proxy hosts grouped by inbound tag.
         * @summary Get Hosts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<ProxyHost>; }> {
            return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve inbound configurations grouped by protocol.
         * @summary Get Inbounds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInbounds(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<ProxyInbound>; }> {
            return localVarFp.getInbounds(options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch system stats including memory, CPU, and user metrics.
         * @summary Get System Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemStats(options?: RawAxiosRequestConfig): AxiosPromise<SystemStats> {
            return localVarFp.getSystemStats(options).then((request) => request(axios, basePath));
        },
        /**
         * Modify proxy hosts and update the configuration.
         * @summary Modify Hosts
         * @param {{ [key: string]: Array<ProxyHost>; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyHosts(requestBody: { [key: string]: Array<ProxyHost>; }, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<ProxyHost>; }> {
            return localVarFp.modifyHosts(requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * Get a list of proxy hosts grouped by inbound tag.
     * @summary Get Hosts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getHosts(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Retrieve inbound configurations grouped by protocol.
     * @summary Get Inbounds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getInbounds(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getInbounds(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Fetch system stats including memory, CPU, and user metrics.
     * @summary Get System Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemStats(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getSystemStats(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify proxy hosts and update the configuration.
     * @summary Modify Hosts
     * @param {{ [key: string]: Array<ProxyHost>; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public modifyHosts(requestBody: { [key: string]: Array<ProxyHost>; }, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).modifyHosts(requestBody, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeNextPlan: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('activeNextPlan', 'username', username)
            const localVarPath = `/api/user/{username}/active-next`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC timestamp for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxies**: Dictionary of protocol settings (e.g., `vmess`, `vless`). - **inbounds**: Dictionary of protocol tags to specify inbound connections. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Add User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('addUser', 'userCreate', userCreate)
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredUsers: async (expiredAfter?: string | null, expiredBefore?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/expired`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (expiredAfter !== undefined) {
                localVarQueryParameter['expired_after'] = (expiredAfter as any instanceof Date) ?
                    (expiredAfter as any).toISOString() :
                    expiredAfter;
            }

            if (expiredBefore !== undefined) {
                localVarQueryParameter['expired_before'] = (expiredBefore as any instanceof Date) ?
                    (expiredBefore as any).toISOString() :
                    expiredBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredUsers: async (expiredAfter?: string | null, expiredBefore?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/expired`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (expiredAfter !== undefined) {
                localVarQueryParameter['expired_after'] = (expiredAfter as any instanceof Date) ?
                    (expiredAfter as any).toISOString() :
                    expiredAfter;
            }

            if (expiredBefore !== undefined) {
                localVarQueryParameter['expired_before'] = (expiredBefore as any instanceof Date) ?
                    (expiredBefore as any).toISOString() :
                    expiredBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUser', 'username', username)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsage: async (username: string, start?: string, end?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserUsage', 'username', username)
            const localVarPath = `/api/user/{username}/usage`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {string | null} [search] 
         * @param {Array<string> | null} [admin] 
         * @param {UserStatus} [status] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (offset?: number, limit?: number, username?: Array<string>, search?: string | null, admin?: Array<string> | null, status?: UserStatus, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (username) {
                localVarQueryParameter['username'] = username;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (admin) {
                localVarQueryParameter['admin'] = admin;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsage: async (start?: string, end?: string, admin?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (admin) {
                localVarQueryParameter['admin'] = admin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC timestamp for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **inbounds**: Dictionary of new protocol tags to specify inbound connections. Empty dictionary means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser: async (username: string, userModify: UserModify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('modifyUser', 'username', username)
            // verify required parameter 'userModify' is not null or undefined
            assertParamExists('modifyUser', 'userModify', userModify)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userModify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('removeUser', 'username', username)
            const localVarPath = `/api/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserDataUsage: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('resetUserDataUsage', 'username', username)
            const localVarPath = `/api/user/{username}/reset`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersDataUsage: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/users/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserSubscription: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('revokeUserSubscription', 'username', username)
            const localVarPath = `/api/user/{username}/revoke_sub`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOwner: async (username: string, adminUsername: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('setOwner', 'username', username)
            // verify required parameter 'adminUsername' is not null or undefined
            assertParamExists('setOwner', 'adminUsername', adminUsername)
            const localVarPath = `/api/user/{username}/set-owner`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (adminUsername !== undefined) {
                localVarQueryParameter['admin_username'] = adminUsername;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activeNextPlan(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeNextPlan(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.activeNextPlan']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC timestamp for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxies**: Dictionary of protocol settings (e.g., `vmess`, `vless`). - **inbounds**: Dictionary of protocol tags to specify inbound connections. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Add User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUser(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.addUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteExpiredUsers(expiredAfter, expiredBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.deleteExpiredUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string | null>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExpiredUsers(expiredAfter, expiredBefore, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getExpiredUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserUsage(username: string, start?: string, end?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserUsagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserUsage(username, start, end, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUserUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {string | null} [search] 
         * @param {Array<string> | null} [admin] 
         * @param {UserStatus} [status] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(offset?: number, limit?: number, username?: Array<string>, search?: string | null, admin?: Array<string> | null, status?: UserStatus, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(offset, limit, username, search, admin, status, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersUsage(start?: string, end?: string, admin?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersUsagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersUsage(start, end, admin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getUsersUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC timestamp for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **inbounds**: Dictionary of new protocol tags to specify inbound connections. Empty dictionary means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUser(username, userModify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.modifyUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUser(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUser(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.removeUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUserDataUsage(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUserDataUsage(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resetUserDataUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetUsersDataUsage(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetUsersDataUsage(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.resetUsersDataUsage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeUserSubscription(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeUserSubscription(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.revokeUserSubscription']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setOwner(username, adminUsername, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.setOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Reset user by next plan
         * @summary Active Next Plan
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activeNextPlan(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.activeNextPlan(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC timestamp for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxies**: Dictionary of protocol settings (e.g., `vmess`, `vless`). - **inbounds**: Dictionary of protocol tags to specify inbound connections. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
         * @summary Add User
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUser(userCreate: UserCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.addUser(userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
         * @summary Delete Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.deleteExpiredUsers(expiredAfter, expiredBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
         * @summary Get Expired Users
         * @param {string | null} [expiredAfter] 
         * @param {string | null} [expiredBefore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig): AxiosPromise<Array<string | null>> {
            return localVarFp.getExpiredUsers(expiredAfter, expiredBefore, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user information
         * @summary Get User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Get users usage
         * @summary Get User Usage
         * @param {string} username 
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserUsage(username: string, start?: string, end?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserUsagesResponse> {
            return localVarFp.getUserUsage(username, start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users
         * @summary Get Users
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {Array<string>} [username] 
         * @param {string | null} [search] 
         * @param {Array<string> | null} [admin] 
         * @param {UserStatus} [status] 
         * @param {string} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(offset?: number, limit?: number, username?: Array<string>, search?: string | null, admin?: Array<string> | null, status?: UserStatus, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.getUsers(offset, limit, username, search, admin, status, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all users usage
         * @summary Get Users Usage
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {Array<string> | null} [admin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersUsage(start?: string, end?: string, admin?: Array<string> | null, options?: RawAxiosRequestConfig): AxiosPromise<UsersUsagesResponse> {
            return localVarFp.getUsersUsage(start, end, admin, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC timestamp for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **inbounds**: Dictionary of new protocol tags to specify inbound connections. Empty dictionary means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
         * @summary Modify User
         * @param {string} username 
         * @param {UserModify} userModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.modifyUser(username, userModify, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a user
         * @summary Remove User
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUser(username: string, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset user data usage
         * @summary Reset User Data Usage
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUserDataUsage(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.resetUserDataUsage(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset all users data usage
         * @summary Reset Users Data Usage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetUsersDataUsage(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetUsersDataUsage(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke users subscription (Subscription link and proxies)
         * @summary Revoke User Subscription
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserSubscription(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.revokeUserSubscription(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Set a new owner (admin) for a user.
         * @summary Set Owner
         * @param {string} username 
         * @param {string} adminUsername 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.setOwner(username, adminUsername, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Reset user by next plan
     * @summary Active Next Plan
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public activeNextPlan(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).activeNextPlan(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Add a new user  - **username**: 3 to 32 characters, can include a-z, 0-9, and underscores. - **status**: User\'s status, defaults to `active`. Special rules if `on_hold`. - **expire**: UTC timestamp for account expiration. Use `0` for unlimited. - **data_limit**: Max data usage in bytes (e.g., `1073741824` for 1GB). `0` means unlimited. - **data_limit_reset_strategy**: Defines how/if data limit resets. `no_reset` means it never resets. - **proxies**: Dictionary of protocol settings (e.g., `vmess`, `vless`). - **inbounds**: Dictionary of protocol tags to specify inbound connections. - **note**: Optional text field for additional user information or notes. - **on_hold_timeout**: UTC timestamp when `on_hold` status should start or end. - **on_hold_expire_duration**: Duration (in seconds) for how long the user should stay in `on_hold` status. - **next_plan**: Next user plan (resets after use).
     * @summary Add User
     * @param {UserCreate} userCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public addUser(userCreate: UserCreate, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).addUser(userCreate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Delete users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided
     * @summary Delete Expired Users
     * @param {string | null} [expiredAfter] 
     * @param {string | null} [expiredBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteExpiredUsers(expiredAfter, expiredBefore, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get users who have expired within the specified date range.  - **expired_after** UTC datetime (optional) - **expired_before** UTC datetime (optional) - At least one of expired_after or expired_before must be provided for filtering - If both are omitted, returns all expired users
     * @summary Get Expired Users
     * @param {string | null} [expiredAfter] 
     * @param {string | null} [expiredBefore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getExpiredUsers(expiredAfter?: string | null, expiredBefore?: string | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getExpiredUsers(expiredAfter, expiredBefore, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get user information
     * @summary Get User
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUser(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUser(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get users usage
     * @summary Get User Usage
     * @param {string} username 
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserUsage(username: string, start?: string, end?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserUsage(username, start, end, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get all users
     * @summary Get Users
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {Array<string>} [username] 
     * @param {string | null} [search] 
     * @param {Array<string> | null} [admin] 
     * @param {UserStatus} [status] 
     * @param {string} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(offset?: number, limit?: number, username?: Array<string>, search?: string | null, admin?: Array<string> | null, status?: UserStatus, sort?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsers(offset, limit, username, search, admin, status, sort, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get all users usage
     * @summary Get Users Usage
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {Array<string> | null} [admin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsersUsage(start?: string, end?: string, admin?: Array<string> | null, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getUsersUsage(start, end, admin, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify an existing user  - **username**: Cannot be changed. Used to identify the user. - **status**: User\'s new status. Can be \'active\', \'disabled\', \'on_hold\', \'limited\', or \'expired\'. - **expire**: UTC timestamp for new account expiration. Set to `0` for unlimited, `null` for no change. - **data_limit**: New max data usage in bytes (e.g., `1073741824` for 1GB). Set to `0` for unlimited, `null` for no change. - **data_limit_reset_strategy**: New strategy for data limit reset. Options include \'daily\', \'weekly\', \'monthly\', or \'no_reset\'. - **proxies**: Dictionary of new protocol settings (e.g., `vmess`, `vless`). Empty dictionary means no change. - **inbounds**: Dictionary of new protocol tags to specify inbound connections. Empty dictionary means no change. - **note**: New optional text for additional user information or notes. `null` means no change. - **on_hold_timeout**: New UTC timestamp for when `on_hold` status should start or end. Only applicable if status is changed to \'on_hold\'. - **on_hold_expire_duration**: New duration (in seconds) for how long the user should stay in `on_hold` status. Only applicable if status is changed to \'on_hold\'. - **next_plan**: Next user plan (resets after use).  Note: Fields set to `null` or omitted will not be modified.
     * @summary Modify User
     * @param {string} username 
     * @param {UserModify} userModify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public modifyUser(username: string, userModify: UserModify, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).modifyUser(username, userModify, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Remove a user
     * @summary Remove User
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeUser(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).removeUser(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Reset user data usage
     * @summary Reset User Data Usage
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUserDataUsage(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resetUserDataUsage(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Reset all users data usage
     * @summary Reset Users Data Usage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public resetUsersDataUsage(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).resetUsersDataUsage(options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Revoke users subscription (Subscription link and proxies)
     * @summary Revoke User Subscription
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public revokeUserSubscription(username: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).revokeUserSubscription(username, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Set a new owner (admin) for a user.
     * @summary Set Owner
     * @param {string} username 
     * @param {string} adminUsername 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setOwner(username: string, adminUsername: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).setOwner(username, adminUsername, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



/**
 * UserTemplateApi - axios parameter creator
 * @export
 */
export const UserTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new user template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Add User Template
         * @param {UserTemplateCreate} userTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTemplate: async (userTemplateCreate: UserTemplateCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userTemplateCreate' is not null or undefined
            assertParamExists('addUserTemplate', 'userTemplateCreate', userTemplateCreate)
            const localVarPath = `/api/user_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTemplateCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get User Template information with id
         * @summary Get User Template Endpoint
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTemplateEndpoint: async (templateId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('getUserTemplateEndpoint', 'templateId', templateId)
            const localVarPath = `/api/user_template/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of User Templates with optional pagination
         * @summary Get User Templates
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTemplates: async (offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user_template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify User Template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Modify User Template
         * @param {number} templateId 
         * @param {UserTemplateModify} userTemplateModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUserTemplate: async (templateId: number, userTemplateModify: UserTemplateModify, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('modifyUserTemplate', 'templateId', templateId)
            // verify required parameter 'userTemplateModify' is not null or undefined
            assertParamExists('modifyUserTemplate', 'userTemplateModify', userTemplateModify)
            const localVarPath = `/api/user_template/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userTemplateModify, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a User Template by its ID
         * @summary Remove User Template
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTemplate: async (templateId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('removeUserTemplate', 'templateId', templateId)
            const localVarPath = `/api/user_template/{template_id}`
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTemplateApi - functional programming interface
 * @export
 */
export const UserTemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new user template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Add User Template
         * @param {UserTemplateCreate} userTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserTemplate(userTemplateCreate: UserTemplateCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserTemplate(userTemplateCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTemplateApi.addUserTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get User Template information with id
         * @summary Get User Template Endpoint
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTemplateEndpoint(templateId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTemplateEndpoint(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTemplateApi.getUserTemplateEndpoint']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of User Templates with optional pagination
         * @summary Get User Templates
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTemplates(offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTemplateResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTemplates(offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTemplateApi.getUserTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Modify User Template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Modify User Template
         * @param {number} templateId 
         * @param {UserTemplateModify} userTemplateModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyUserTemplate(templateId: number, userTemplateModify: UserTemplateModify, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTemplateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyUserTemplate(templateId, userTemplateModify, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTemplateApi.modifyUserTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove a User Template by its ID
         * @summary Remove User Template
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserTemplate(templateId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserTemplate(templateId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTemplateApi.removeUserTemplate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserTemplateApi - factory interface
 * @export
 */
export const UserTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTemplateApiFp(configuration)
    return {
        /**
         * Add a new user template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Add User Template
         * @param {UserTemplateCreate} userTemplateCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserTemplate(userTemplateCreate: UserTemplateCreate, options?: RawAxiosRequestConfig): AxiosPromise<UserTemplateResponse> {
            return localVarFp.addUserTemplate(userTemplateCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get User Template information with id
         * @summary Get User Template Endpoint
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTemplateEndpoint(templateId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserTemplateResponse> {
            return localVarFp.getUserTemplateEndpoint(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of User Templates with optional pagination
         * @summary Get User Templates
         * @param {number} [offset] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTemplates(offset?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserTemplateResponse>> {
            return localVarFp.getUserTemplates(offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify User Template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
         * @summary Modify User Template
         * @param {number} templateId 
         * @param {UserTemplateModify} userTemplateModify 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyUserTemplate(templateId: number, userTemplateModify: UserTemplateModify, options?: RawAxiosRequestConfig): AxiosPromise<UserTemplateResponse> {
            return localVarFp.modifyUserTemplate(templateId, userTemplateModify, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove a User Template by its ID
         * @summary Remove User Template
         * @param {number} templateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserTemplate(templateId: number, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.removeUserTemplate(templateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTemplateApi - object-oriented interface
 * @export
 * @class UserTemplateApi
 * @extends {BaseAPI}
 */
export class UserTemplateApi extends BaseAPI {
    /**
     * Add a new user template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
     * @summary Add User Template
     * @param {UserTemplateCreate} userTemplateCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTemplateApi
     */
    public addUserTemplate(userTemplateCreate: UserTemplateCreate, options?: RawAxiosRequestConfig) {
        return UserTemplateApiFp(this.configuration).addUserTemplate(userTemplateCreate, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get User Template information with id
     * @summary Get User Template Endpoint
     * @param {number} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTemplateApi
     */
    public getUserTemplateEndpoint(templateId: number, options?: RawAxiosRequestConfig) {
        return UserTemplateApiFp(this.configuration).getUserTemplateEndpoint(templateId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Get a list of User Templates with optional pagination
     * @summary Get User Templates
     * @param {number} [offset] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTemplateApi
     */
    public getUserTemplates(offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return UserTemplateApiFp(this.configuration).getUserTemplates(offset, limit, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Modify User Template  - **name** can be up to 64 characters - **data_limit** must be in bytes and larger or equal to 0 - **expire_duration** must be in seconds and larger or equat to 0 - **inbounds** dictionary of protocol:inbound_tags, empty means all inbounds
     * @summary Modify User Template
     * @param {number} templateId 
     * @param {UserTemplateModify} userTemplateModify 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTemplateApi
     */
    public modifyUserTemplate(templateId: number, userTemplateModify: UserTemplateModify, options?: RawAxiosRequestConfig) {
        return UserTemplateApiFp(this.configuration).modifyUserTemplate(templateId, userTemplateModify, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }

    /**
     * Remove a User Template by its ID
     * @summary Remove User Template
     * @param {number} templateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTemplateApi
     */
    public removeUserTemplate(templateId: number, options?: RawAxiosRequestConfig) {
        return UserTemplateApiFp(this.configuration).removeUserTemplate(templateId, options).then((request) => request(this.axios, this.basePath)).then(({data}) => data);
    }
}



